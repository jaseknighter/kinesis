-- lib/sun_mode_2.lua 
-- this mode uses the reflection library
-- Reference: https://monome.org/docs/norns/reference/lib/reflection

-- note about the "event router" (defined below)
--  events generated by the reflection library
--    are consolidated in an event router.
--  connect reflection events to functions
--  for controlling sounds through this router

sun_mode_2 = {}

-- define state names.
local states = {'r','p','l'}  -- record, play, loop

------------------------------------------
-- initialization and deinitialization
------------------------------------------
function sun_mode_2.init(self)
  self.reflection_indices = {}
  self.max_cursor = 8 * 16
  self.state = 1  -- 1 = record, 2 = play, 3 = loop
  self.grain_mode = 1 -- 1 = granulate live audio, 2 = granulate an audio file
  -- define which rays have reflectors
  if self.index == 1 then
    self.reflector_locations = {1,3,5,7,9,11,13,15}
  else
    self.reflector_locations = {2,4,6,8,10,12,14,16}
  end

  -- set the selected reflector
  self.selected_ray = self.reflector_locations[1]

  -- initialize state tables (keyed by reflector id)
  self.record       = {}
  self.play         = {}
  self.loop         = {}
  self.engine_vals  = {}
  for i = 1, #self.reflector_locations do
    local rid = self.reflector_locations[i]
    self.record[rid]  = 0
    self.play[rid]    = 1
    self.loop[rid]    = 1
    sun_mode_2.deselect_reflector(self, rid)
  end

  sun_mode_2.init_reflectors(self)
  sun_mode_2.hide_non_reflector_rays(self)
  
  -- select the initial reflector
  sun_mode_2.select_reflector(self, self.selected_ray)

  sun_mode_2.init_sounds(self)

  ------------------------------------------
  -- add params
  ------------------------------------------
  params:add_option("mode","set mode",{"live","recorded"})
  params:set_action("mode",function(mode) 
    -- mode 1 = granulate live audio
    -- mode 2 = granulate an audio file
    if mode == 2 then
      local file = params:get("sample")
      if file ~= "-" then
        self.grain_mode = mode
        engine.sample(1,file)
      else
         print("select a file before setting mode to 'recorded'")
         params:set("mode",1)
      end
    else
      self.grain_mode = mode
      engine.live(1)
    end

  end)
  
  params:add_file("sample","sample")
  params:set_action("sample",function(file)
    if params:get("mode") == 2 then
      print("new sample ",file)
      if file~="-" then
        engine.sample(1,file)
      end
    end
  end)
  params:add_trigger("freeze_grains","freeze grains")
  params:set_action("freeze_grains", function()
    -- to freeze grains we need to:
    --   set speed and jitter to 0
    --   for live granulation set pre_level to 1 and rec_level to 0 
    --   note: if there are reflection recordings running for these, freezing might not exactly happen
    local speed_reflector            =  sun_mode_2.get_reflector_id_by_engine_command_name(self,"sp")
    local jitter_reflector           =  sun_mode_2.get_reflector_id_by_engine_command_name(self,"jt")
    local prerecord_level_reflector  =  sun_mode_2.get_reflector_id_by_engine_command_name(self,"pl")
    local record_level_reflector     =  sun_mode_2.get_reflector_id_by_engine_command_name(self,"rl")
    sun_mode_2.update_engine(self, 1, "sp", 64)
    sun_mode_2.update_engine(self, 1, "jt", 0)
    sun_mode_2.update_engine(self, 1, "pl", 128) 
    sun_mode_2.update_engine(self, 1, "rl", 0)
    clock.run(function() 
      clock.sleep(0.1)
      sun_mode_2.set_reflector_cursor(self, speed_reflector           , 64)
      sun_mode_2.set_reflector_cursor(self, jitter_reflector          , 0)
      sun_mode_2.set_reflector_cursor(self, prerecord_level_reflector , 128)
      sun_mode_2.set_reflector_cursor(self, record_level_reflector    , 0)
    end)
  end)

  params:add_trigger("reset_grain_phase","reset grain phase")
  params:set_action("reset_grain_phase", function()
    engine_params = {}
    local voice = 1 -- note: this would need to be changed if we update the code for multiple voices (e.g. one per sun)
    for reflector_location_ix=1,#engine_commands do
      local reflector_id = self.reflector_locations[reflector_location_ix]
      local engine_command_data = sun_mode_2.get_engine_command_data(self,reflector_id) 
      local engine_val = self.engine_vals[reflector_id]
      local engine_command_name = engine_command_data[1]
      engine_params[engine_command_name]=engine_val
    end
    -- engine.reload_grain_player(voice,speed,density,pos,size,jitter,grain_env)
    engine.reload_grain_player(
      voice,
      engine_params["sp"], -- speed
      engine_params["dn"],
      engine_params["ps"],
      engine_params["sz"],
      engine_params["jt"],
      engine_params["ge"]
    )
  end)

  -- define a deinit function to
  --   remove any variables or tables that might stick around
  --   after switching to a different sun mode
  --   for example: a lattice or reflection instance
  self.deinit = function()
    print("deinit sun mode: 2")
    self.lattice:stop()
    self.lattice = nil
    for reflector=1,#self.reflectors do
      self.reflectors[reflector]:stop()
      self.reflectors[reflector]:clear()
    end
    self.deinit = nil
  end  
end

------------------------------------------
-- helpers;
------------------------------------------
function sun_mode_2.hide_non_reflector_rays(self)
  for ray = 1, NUM_RAYS do
    if not table_contains(self.reflector_locations, ray) then
      self:set_ray_brightness(ray, 0)
    end
  end
end

------------------------------------------
-- get minimum brightness for a reflector
------------------------------------------
function sun_mode_2.get_MIN_LEVEL(self, reflector_id)
  local min_l = 0
  for i = 1, #self.reflector_locations do
    if reflector_id == self.reflector_locations[i] then
      min_l = 3
      break
    end
  end
  return min_l
end

------------------------------------------
-- get the next reflector from reflector_locations
------------------------------------------
function sun_mode_2.get_next_ray(self, delta)
  local current_index = nil
  for i = 1, #self.reflector_locations do
    if self.selected_ray == self.reflector_locations[i] then
      current_index = i
      break
    end
  end
  if not current_index then current_index = 1 end
  local next_index = util.wrap(current_index + delta, 1, #self.reflector_locations)
  return self.reflector_locations[next_index]
end

------------------------------------------
-- encoder handler
------------------------------------------
function sun_mode_2.enc(self, n, delta)
  if n == 1 then
    self.state = util.clamp(self.state + delta, 1, #states)
  else
    if alt_key == true then
      -- Change the selected reflector.
      -- sun_mode_2.deselect_reflector(self, self.selected_ray) -- TODO: REMOVE THIS LINE: NOT NEEDED
      self.selected_ray = sun_mode_2.get_next_ray(self, delta)
      sun_mode_2.select_reflector(self, self.selected_ray)
      sun_mode_2.draw_reflector_cursor(self, self.selected_ray)
    else
      -- Adjust reflector cursor for the selected reflector.
      sun_mode_2.set_reflector_cursor_rel(self, self.selected_ray, delta)
      sun_mode_2.draw_reflector_cursor(self, self.selected_ray)
    end
  end
end

------------------------------------------
-- key handler
------------------------------------------
function sun_mode_2.key(self, n, z)
  local reflector_id = self.selected_ray
  if self.state == 1 then  -- record state
    if self.record[reflector_id] == 1 and z == 0 then
      self.record[reflector_id] = 0
      self.reflectors[reflector_id]:set_rec(0)
      print("key: stop reflector recording")    
    elseif self.record[reflector_id] == 0 and z == 0 then
      print("key: start reflector recording",reflector_id,self.reflectors[reflector_id])
      self.record[reflector_id] = 1
      self.reflectors[reflector_id]:clear()
      self.reflectors[reflector_id]:set_rec(1)
    end
  elseif self.state == 2 then -- play state
    if z == 0 then
      if n == 2 then
        if self.play[reflector_id] == 1 then
          self.play[reflector_id] = 0
          print("toggle_play: stop reflector playing", reflector_id)
          if self.reflectors[reflector_id] and self.reflectors[reflector_id].stop then
            self.reflectors[reflector_id]:stop()
          end
        else
          self.play[reflector_id] = 1
          print("toggle_play: start reflector playing", reflector_id)
          if self.reflectors[reflector_id] and self.reflectors[reflector_id].start then
            self.reflectors[reflector_id]:start()
          end
        end
      end
    end
  elseif self.state == 3 then  -- loop state
    if self.loop[reflector_id] == 1 and z == 0 then
      self.loop[reflector_id] = 0
      print("key: stop reflector looping")
      self.reflectors[reflector_id]:set_loop(0)
    elseif self.loop[reflector_id] == 0 and z == 0 then
      self.loop[reflector_id] = 1
      print("key: start reflector looping")
      self.reflectors[reflector_id]:set_loop(1)
    end
  end
end

------------------------------------------
-- get last selected photon for a reflector
------------------------------------------
function sun_mode_2.get_last_selected_photon(self, reflector_id)
  local last_ph, last_ph_brightness
  if self.reflection_indices[reflector_id] then
    local cursor = self.reflection_indices[reflector_id].reflection_cursor
    local q, r = quotient_remainder(cursor, NUM_RAYS)
    last_ph = q + 1
    last_ph_brightness = r * NUM_RAYS
    if last_ph_brightness == 1 then last_ph_brightness = 0 end
  end
  return last_ph, last_ph_brightness
end

------------------------------------------
-- calculate photon brightness for a reflector
------------------------------------------
function sun_mode_2.get_photon_brightness(self, reflector_id, photon)
  local brightness, last_ph, last_ph_brightness
  if self.reflection_indices[reflector_id] then
    last_ph, last_ph_brightness = sun_mode_2.get_last_selected_photon(self, reflector_id)
    if photon < last_ph then
      brightness = MAX_LEVEL
    elseif photon == last_ph then
      brightness = last_ph_brightness
    else
      brightness = sun_mode_2.get_MIN_LEVEL(self, reflector_id)
    end
  else
    brightness = sun_mode_2.get_MIN_LEVEL(self, reflector_id)
  end
  return brightness, last_ph
end

------------------------------------------
-- draw the reflector cursor for a given reflector
------------------------------------------
function sun_mode_2.draw_reflector_cursor(self, reflector_id)
  local brightness_fn = function(photon_id,photon)
    local brightness = sun_mode_2.get_photon_brightness(self, reflector_id, photon_id)
    photon:set_brightness(brightness)
    return nil
  end
  self:set_ray_brightness(reflector_id,brightness_fn)
end

------------------------------------------
-- set reflector cursor (absolute)
------------------------------------------
function sun_mode_2.set_reflector_cursor(self, reflector_id, val)
  if not self.reflection_indices[reflector_id] then
    self.reflection_indices[reflector_id] = { reflection_cursor = 1 }
  end
  
  self.reflection_indices[reflector_id].reflection_cursor = val
  print("set_reflector_cursor", reflector_id, val)
  sun_mode_2.draw_reflector_cursor(self, reflector_id)
end

------------------------------------------
-- set reflector cursor (relative)
------------------------------------------
function sun_mode_2.set_reflector_cursor_rel(self, reflector_id, delta)
  if not self.reflection_indices[reflector_id] then
    self.reflection_indices[reflector_id] = { reflection_cursor = 1 }
  end
  local cursor = self.reflection_indices[reflector_id].reflection_cursor
  local new_cursor = util.clamp(cursor + delta, 1, self.max_cursor)
  self.reflection_indices[reflector_id].reflection_cursor = new_cursor
  -- Store reflector data.
  local new_data = { reflector = reflector_id, value = new_cursor }
  sun_mode_2.store_reflector_data(self, reflector_id, new_data)

  -- pass the event value to the router
  sun_mode_2.event_router(self, reflector_id, "process", new_data.value)

end

------------------------------------------
-- deselect a reflector
------------------------------------------
function sun_mode_2.deselect_reflector(self, reflector_id)
  self:set_ray_brightness(reflector_id,function() 
    return sun_mode_2.get_MIN_LEVEL(self, reflector_id)
  end)
end

------------------------------------------
-- select a reflector
------------------------------------------
function sun_mode_2.select_reflector(self, reflector_id)
  -- First, hide all non-reflector rays.
  sun_mode_2.hide_non_reflector_rays(self)
  -- Then update the display for the selected reflector.
  local set_reflector_brightness = function(photon_id, photon)
    if sun_mode_2.ray_has_cursor(self) then
      sun_mode_2.draw_reflector_cursor(self, reflector_id)
    end
    if photon_id < PHOTONS_PER_RAY then
      return MIN_LEVEL
    else
      local brightness = sun_mode_2.get_photon_brightness(self, reflector_id, photon_id)
      photon:morph_photon(MAX_LEVEL, brightness, 1, 15, 'lin', nil, reflector_id)
      return nil
    end
  end
  self:set_ray_brightness(reflector_id,set_reflector_brightness)
  -- for photon = 1, PHOTONS_PER_RAY do
    -- local p = self:get_photon(reflector_id, photon)
    -- if photon < PHOTONS_PER_RAY then
    --   p:set_brightness(MIN_LEVEL)
    -- else
    --   local brightness = sun_mode_2.get_photon_brightness(self, reflector_id, photon)
    --   local morphing_callback = function(next_val, done)
    --   end
    --   p:morph_photon(15, brightness, 1, 15, 'lin', morphing_callback, reflector_id)
    -- end
    -- if sun_mode_2.ray_has_cursor(self) then
    --   sun_mode_2.draw_reflector_cursor(self, reflector_id)
    -- end
  -- end
end

------------------------------------------
-- check if the currently selected reflector has cursor data
------------------------------------------
function sun_mode_2.ray_has_cursor(self)
  return self.reflection_indices[self.selected_ray] ~= nil
end

------------------------------------------
-- calculate pointer position (for display)
------------------------------------------
function sun_mode_2.calc_pointer_position(self)
  local center_x = (self.index == 1) and 32 or 96
  local center_y = 32
  local angle = -math.pi/2 + (self.selected_ray - 1) * (2 * math.pi / NUM_RAYS)
  local distance = SUN_RADIUS - 1
  local x = util.round(center_x + distance * math.cos(angle))
  local y = util.round(center_y + distance * math.sin(angle))
  return x, y
end

------------------------------------------
-- redraw routine.
------------------------------------------
function sun_mode_2.redraw(self)
  local bottom_left_x = (self.index == 1) and 1 or 65
  local bottom_left_y = 62
  screen.move(bottom_left_x, bottom_left_y)
  screen.rect(bottom_left_x, bottom_left_y-5, 18, 8)
  screen.level(0)
  screen.fill()
  
  screen.move(bottom_left_x, bottom_left_y)
  screen.level(3)
  local state_text = tostring(self.selected_ray)
  -- update lower left labels for record/play/loop
  if self.state == 1 then
    local rec = (self.record[self.selected_ray] == 0) and "-" or "+"
    state_text = state_text .. states[self.state] .. rec
  elseif self.state == 2 then
    local play = (self.play[self.selected_ray] == 0) and "-" or "+"
    state_text = state_text .. states[self.state] .. play
  elseif self.state == 3 then
    local loop = (self.loop[self.selected_ray] == 0) and "-" or "+"
    state_text = state_text .. states[self.state] .. loop
  end
  screen.text(state_text)

  -- update lower right labels for engine commands
  local engine_command_data = sun_mode_2.get_engine_command_data(self,self.selected_ray) 
  local engine_val = self.engine_vals[self.selected_ray]
  local engine_command_name = engine_command_data[1]

  local top_right_x = (self.index == 1) and 60 or 127
  local top_right_y = 5
  screen.move(top_right_x, top_right_y)
  screen.rect(top_right_x, top_right_y-5, 18, 8)
  screen.level(0)
  screen.fill()
  
  screen.move(top_right_x, top_right_y)
  screen.level(3)
  screen.text_right(engine_command_name)

  if engine_val then
    if engine_val < 10 then 
      engine_val = util.round(engine_val,0.01)
    else
      engine_val = util.round(engine_val,0.1)
    end 
    local bottom_right_x = (self.index == 1) and 60 or 127
    local bottom_right_y = 62
    screen.move(bottom_right_x, bottom_right_y)
    screen.rect(bottom_right_x, bottom_right_y-5, 18, 8)
    screen.level(0)
    screen.fill()
  
    screen.move(bottom_right_x, bottom_right_y)
    screen.level(3)
    local engine_val = tostring(engine_val)
    screen.text_right(engine_val)
  end
  


  local point_x, point_y = sun_mode_2.calc_pointer_position(self)
  screen.level(0)
  screen.circle(point_x, point_y, 2)
  screen.fill()
end

------------------------------------------
------------------------------------------
--      reflection code       --
------------------------------------------
------------------------------------------
function sun_mode_2.store_reflector_data(self, reflector_id, data)
  if self.reflectors[reflector_id] then
    -- print("store reflector data",reflector_id,self.reflectors[reflector_id],data.reflector,data.value)
    self.reflectors[reflector_id]:watch{
      reflector = data.reflector,
      value = data.value
    }
  else
    print("can't store reflector data",reflector_id,self.reflectors[reflector_id])

  end
end

function sun_mode_2.init_reflectors(self)
  self.reflectors = {}
  self.reflector_data = {}
  self.reflector_processors = {}

  for i = 1, #self.reflector_locations do
    local reflector_id = self.reflector_locations[i]
    self.reflector_data[reflector_id] = {}

    self.reflectors[reflector_id] = reflection.new()
    --[[ 0_0 ]]-- set looping on by default
    self.reflectors[reflector_id]:set_loop(1)                   
    self.reflectors[reflector_id].process = function(event)
      local value = event.value
      
      -- update the ui
      sun_mode_2.set_reflector_cursor(self, reflector_id, value)

      -- pass the event value to the router
      sun_mode_2.event_router(self, reflector_id, "process", value)

    end

    -- end-of-loop callback
    self.reflectors[reflector_id].end_of_loop_callback = function()
      sun_mode_2.event_router(self, reflector_id, "end_of_loop")
      -- print("reflector step", reflector_id)
    end
    
    -- (optional) callback for recording start
    self.reflectors[reflector_id].start_callback = function()
      sun_mode_2.event_router(self, reflector_id, "record_start")
      -- print("recording started", reflector_id)
    end
    
    -- (optional) callback for recording stop
    self.reflectors[reflector_id].end_of_rec_callback = function()
      sun_mode_2.event_router(self, reflector_id, "record_end")
      -- print("recording ended", reflector_id)
    end

    -- (optional) callback for reflector step
    self.reflectors[reflector_id].step_callback = function()
      sun_mode_2.event_router(self, reflector_id, "step")
      -- print("reflector step", reflector_id)
    end
    
    self.reflectors[reflector_id].end_callback = function()
      -- print("pattern end callback", reflector_id)
      sun_mode_2.event_router(self, reflector_id, "pattern_end")
      -- local is_looping = (self.loop[reflector_id] == 1)
      -- if not is_looping then self.play[reflector_id] = 0 end
    end
  end
end

--======--===========================--======--
--======--111111111111111111111111111--======--
--===========    sun sound code     =========--
--======--111111111111111111111111111--======--    
--======--===========================--======--
------------------------------------------
-- init sounds
------------------------------------------
function sun_mode_2.init_sounds(self)
  -- init lattice
  sun_mode_2.init_lattice(self)
  
  -- sync the active photon to supercollider sunshine engine values
  -- note: at the moment each time a sun is set to this mode (#2)
  --         the sunshine engine voice will be reset to its default values
  --         since the code currently only defines a single voice for the engine,
  --         and not, for example, one voice per sun
  for reflector_id=1, NUM_RAYS do
    local sc_voice = 1
    local engine_command_data = sun_mode_2.get_engine_command_data(self,reflector_id) 
    if engine_command_data then
      local engine_command_ranges = engine_command_data[3]
      local engine_command_default_val = engine_command_data[4]
      local min = engine_command_ranges[1]
      local max = engine_command_ranges[2]
      
      --set the photon to match the default value 
      --this will send an update to the sc engine to set the default value
      local photon_val = util.linlin(min,max,1,128,engine_command_default_val)
      -- print("init reflector cursor",min,max,engine_command_default_val,photon_val)
      sun_mode_2.set_reflector_cursor(self,reflector_id,photon_val)
      
      --update the engine_vals table to display the value on the screen
      self.engine_vals[reflector_id] = engine_command_default_val
    end
  end
end


------------------------------------------
-- lattice code
------------------------------------------

-- init lattice
function sun_mode_2.init_lattice(self)
  local sun = self.index
  
  self.lattice = lattice:new{
    auto = true,
    ppqn = 96
  }   

  -- make a sprockets for sun1 and sun 2
  self.sprocket_1 = self.lattice:new_sprocket{
    action = function(t) 
      sun_mode_2.event_router(self, nil, "sprocket")
    end,
    division = 1/4,
    enabled = true
  }
  
  self.sprocket_2 = self.lattice:new_sprocket{
    action = function(t) 
      sun_mode_2.event_router(self, nil, "sprocket")
    end,
    division = 1/8,
    enabled = true
  }

  self.lattice:start()
end

------------------------------------------
-- supercollider communication code
------------------------------------------

sun_mode_2.engine_cmd_range_mapper = function (range_data,value)
  local min = range_data[1]
  local max = range_data[2]
  local round = range_data[3]
  local round_precision =  range_data[4] and range_data[4] or 0
  local mapped_val
  if round == true then 
    mapped_val = util.round(util.linlin(1,128,min,max,value),round_precision)
  else
    mapped_val = util.linlin(1,128,min,max,value)
  end
  return mapped_val
end

-- table containing engine command names
--   along with functions to put the reflector values in proper ranges
--   IMPORTANT: the order of the engine commands sets which sun ray/reflector 
--              updates which engine command. if there are more items in the `engine_commands`
--              table than there are items in the `reflector_locations` table, the code will break
engine_commands = {
--  abbr     command              range                 default         
  { "sp",    engine.speed,        { -5,5,true,0.1 },    1         },
  { "dn",    engine.density,      { 1,40,true },        1         },
  { "ps",    engine.pos,          { 0,1 },              0         },
  { "sz",    engine.size,         { 0.01,0.5 },         0.1       },
  { "jt",    engine.jitter,       { 0,1 },              0         },
  { "ge",    engine.grain_env,    { 1,6,true,1 },              0         },
--{ "we",    engine.buf_win_end,  { 0.01,1 },           1         },
  { "rl",    engine.rec_level,    { 0,1,true,0.01 },    1         },
  { "pl",    engine.pre_level,    { 0,1,true,0.01 },    0         },
}

function sun_mode_2.get_engine_command_data(self,reflector_id) 
  local command_location, command_data
  for location=1,#engine_commands do 
    if self.reflector_locations[location] == reflector_id then 
      command_location = location 
      command_data = engine_commands[command_location]
      return command_data
    end
  end
end

-- for each item in the `engine_commands` table, look up the command name acronym
--   which is located in the first slot of the `engine_commands` table
--   and if the acronym matches the one in this functions `engine_command_name` parameter,
--   look up the corresponding `reflector_id` from the `self.reflector_locations` table
function sun_mode_2.get_reflector_id_by_engine_command_name(self, engine_command_name)
  local reflector_id
  for engine_command_ix=1,#engine_commands do
    local engine_command = engine_commands[engine_command_ix]
    local command_name = engine_command[1]
    if command_name == engine_command_name then
      reflector_id = self.reflector_locations[engine_command_ix]
      -- print("found reflector_id", reflector_id)
      return reflector_id
    end
  end
  if not reflector_id then print("couldn't find reflector id for ", engine_command_name) end
end
  
-- update supercollider engine and keep track of the updates
-- note#1: for the third parameter (reflector_id_or_command_name) you can send either 
--         a `reflector_id` 
--         or the two letter acronym for the engine command (e.g. 'sz' for engine.size).
--         see `engine_commands` above for the list of acronyms.
-- note#2: the 4th parameter, `value`, is relative to the photon value (1-128)
--           the update_engine code remaps these values to the ones expected by the supercollider engine
--           for example, setting a value of 128 for speed would be mapped to 5 (i.e. max speed)
function sun_mode_2.update_engine(self, sc_voice, reflector_id_or_command_name, value)
  -- if reflector_id_or_command_name is a number, assumed it is a reflector_id
  --   otherwise, assume it is a command name acronym from the `engine_commmands` table.
  local reflector_id, engine_command_name, engine_command_data
  if type(reflector_id_or_command_name) == "number" then
    reflector_id = reflector_id_or_command_name
    engine_command_data = sun_mode_2.get_engine_command_data(self,reflector_id) 
    engine_command_name = engine_command_data[1]
  else
    engine_command_name = reflector_id_or_command_name
    reflector_id = sun_mode_2.get_reflector_id_by_engine_command_name(self, engine_command_name)
    engine_command_data = sun_mode_2.get_engine_command_data(self,reflector_id) 
  end    
  
  local engine_command_ranges = engine_command_data[3]
  local mapped_val = sun_mode_2.engine_cmd_range_mapper(engine_command_ranges,value)
  local engine_fn = engine_command_data[2]
  self.engine_vals[reflector_id] = mapped_val
  engine_fn(sc_voice,mapped_val)
  print("update engine (reflector/command/mapped value/original)  ", reflector_id, engine_command_name, mapped_val,value)
end
  
------------------------------------------
-- event router (configure controls here)
------------------------------------------
-- define an event router that consolidates 
--   all the reflector events and lattice/sprocket events
function sun_mode_2.event_router(self, reflector_id, event_type, value)
  local sun = self.index
  
  if not self.sprocket_1 or not self.sprocket_2 then return end

  if sun == 1 then
    if event_type == "process" then 
      -- here we are "processing" changes triggered by
      --   encoder 3 and reflector recordings
      local sc_voice = 1
      sun_mode_2.update_engine(self, sc_voice, reflector_id, value)
    end

    if event_type == "sprocket" then 
      -- sun_mode_2.play_note(self) 
    end
    
    -- unused events
    -- if event_type == "end_of_loop"  then --[[ do something with end_of_loop]] end
    -- if event_type == "record_start"  then --[[ do something with record_start]] end
    -- if event_type == "record_end"  then --[[ do something with record_end]] end
    -- if event_type == "step"      then --[[ do something with step]] end
    -- if event_type == "pattern_end"   then --[[ do something with pattern_end]] end
  elseif sun == 2 then
    if event_type == "process" then 
      -- here we are "processing" changes triggered by
      --   encoder 3 and reflector recordings
      local sc_voice = 1
      local engine_command_data = sun_mode_2.get_engine_command_data(self,reflector_id) 
      local engine_command_ranges = engine_command_data[3]
      local mapped_val = sun_mode_2.engine_cmd_range_mapper(engine_command_ranges,value)
      local engine_command_name = engine_command_data[1]
      local engine_fn = engine_command_data[2]
      -- print(engine_fn, mapped_val,engine_command_name)
      self.engine_vals[reflector_id] = mapped_val
      engine_fn(sc_voice,mapped_val)
    end

    if event_type == "sprocket" then 
      -- sun_mode_2.play_note(self)  
    end
    
    if event_type == "end_of_loop"  then 
      -- if reflector_id == 1 then
      --   local curr_div = suns[2].sprocket_2.division
      --   local next_div = curr_div == 1/8 and 1/16 or 1/8
      --   print("sun".. self.index .. ": end of loop 3 next division", next_div) 
      --   suns[2].sprocket_2.division = next_div
      -- else
      --   print("sun".. self.index .. ": end of loop 7 reset swing") 
      --   local curr_swing = suns[2].sprocket_2.swing 
      --   suns[2].sprocket_2:set_swing(curr_swing == 0 and 10 or 0)
      -- end
    end

    -- unused events
    -- if event_type == "record_start"  then --[[ do something with record_start]] end
    -- if event_type == "record_end"  then --[[ do something with record_end]] end
    -- if event_type == "step"      then --[[ do something with step]] end
    -- if event_type == "pattern_end"   then --[[ do something with pattern_end]] end
  end
end



return sun_mode_2

